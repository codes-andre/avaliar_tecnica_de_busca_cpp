#include <iostream>
#include "ArvoreBinariaAVL.h"
#include <chrono>
#include <thread>

// There are other clocks, but this is usually the one you want.
// It corresponds to CLOCK_MONOTONIC at the syscall level.
using Clock = std::chrono::steady_clock;
using std::chrono::time_point;
using std::chrono::duration_cast;
using std::chrono::milliseconds;
using namespace std::literals::chrono_literals;
using std::this_thread::sleep_for;

//RANDOM NUMBERS GENERATED BY THE 'Linear Congruential Generator' ALGORITHM
static const int A = 9;
static const int C = 1;
static const int M = 28000;

//Calcule o tempo total em segundos gasto pela estrutura ABB para armazenar todas as chaves e o tempo gasto por um algoritmo qualquer de ordenação para ordenar o vetor;
//Gere aleatoriamente um grande número de chaves e procure cada uma delas na estrutura de Árvore Binária de Busca(ABB) e no vetor com Busca Binária;
//Calcule o tempo total em segundos gasto pela ABB e pela BB para recuperar todas as chaves;
//Apresente para o usuário os tempos de indexação e recuperação de cada estrutura(BB) e(ABB) e a soma dos seus respectivos tempos.
//

int myrand()
{
	static int prev = 1; // To generate random numbers more than once
	prev = (A * prev + C) % (M+1);
	return prev;
}

int busca_binaria(int *v, int n, int key) {
	int inf = 0, sup = n - 1, meio;
	while (inf <=sup) {
		meio = (inf + sup) / 2;
		if (v[meio] == key) return meio;
		else {
			if (key < v[meio])
				sup = meio - 1;
			else
				inf = meio + 1;
		}
	}
	return -1;
}

void bubble(int *x, int n)
{
	int aux, j, i;
	bool trocou = true;

	for (i = 0; i < n - 1 && trocou == true; i++)
	{
		trocou = false;
		for (j = 0; j < n - i - 1; j++)
			if (x[j] > x[j + 1])
			{
				trocou = true;
				aux = x[j];
				x[j] = x[j + 1];
				x[j + 1] = aux;
			}
	}
}

void main() {
	int min = 0;
	int tamanho;

	std::cout << "Informe o tamanho do conjunto: ";
	std::cin >> tamanho;
	
	int *chaves_procura = (int*)malloc(tamanho * sizeof(int));
	int *chaves_insere = (int*)malloc(tamanho * sizeof(int));

	for (int i = 0; i < tamanho; i++) {
		chaves_insere[i] = min + (rand() % (M - min + 1));
		chaves_procura[i] = myrand();
	}

	ArvoreBinariaAVL *tree = new ArvoreBinariaAVL();

	time_point<Clock> ABB_start_reserve = Clock::now();

	//INSERE ELEMENTOS ALEATORIOS NA ABB
	for (int i = 0; i < tamanho; i++) 
		tree->insere_elemento(chaves_insere[i]);

	time_point<Clock> ABB_end_reserve = Clock::now();
	time_point<Clock> ABB_start_search = Clock::now();

	//BUSCA ELEMENTOS ALEATORIOS NA ABB
	for (int i = 0; i < tamanho; i++) {
		int existe = tree->existe_elemento_int(chaves_procura[i]);
		if (existe != -1) {
			//std::cout << "Existe ABB: [" << i << "]" << existe << std::endl;
		}
	}
	time_point<Clock> ABB_end_search = Clock::now();
	milliseconds ABB_diff_reserve = duration_cast<milliseconds>(ABB_end_reserve - ABB_start_reserve);
	milliseconds ABB_diff_search = duration_cast<milliseconds>(ABB_end_search - ABB_start_search);

	int *vetor = (int*)malloc(tamanho * sizeof(int));
	time_point<Clock> BB_start_reserve_and_order = Clock::now();

	//INSERE ELEMENTOS ALEATORIOS NA BB
	for (int i = 0; i < tamanho; i++) 
		vetor[i] = chaves_insere[i];

	//Ordenar vetor
	bubble(vetor, tamanho);
	time_point<Clock> BB_end_reserve_and_order = Clock::now();
	int find;
	
	time_point<Clock> BB_start_search = Clock::now();
	
	//BUSCA ELEMENTOS ALEATORIOS NA BB - armazena tempo de busca
	for (int i = 0; i < tamanho; i++) {
		find = busca_binaria(vetor, tamanho, chaves_procura[i]);
		if (find != -1){
			//std::cout << "Existe BB: vetor ["<<find<<"] == " << vetor[find] << " == " << search << std::endl;
		}
	}
	time_point<Clock> BB_end_search = Clock::now();
	free(vetor);
	free(chaves_insere);
	free(chaves_procura);

	milliseconds BB_diff_reserve_and_order = duration_cast<milliseconds>(BB_end_reserve_and_order - BB_start_reserve_and_order);
	milliseconds BB_diff_search = duration_cast<milliseconds>(BB_end_search - BB_start_search);
	
	std::cout << "\nABB_armazena = " << ABB_diff_reserve.count() << "ms" << "| BB_armazena_ordena = " << BB_diff_reserve_and_order.count() << "ms" << std::endl;
	std::cout << "ABB_procura = " << ABB_diff_search.count() << "ms" << "| BB_procura = " << BB_diff_search.count() << "ms\n";
	std::cout << "ABB_total = " << ABB_diff_search.count() + ABB_diff_reserve.count() << "ms" << "| BB_total = " << BB_diff_search.count() + BB_diff_reserve_and_order.count() << "ms\n" << std::endl;
}